# reports/views.py

from rest_framework import status
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import action
from rest_framework.response import Response
from django_filters.rest_framework import DjangoFilterBackend
from django.core.mail import send_mail
from django.conf import settings

from .models import (
    Report,
    EmailSendRecord,
    Template,
    ScheduledTask,
    TaskLog,
    IntermediateData,
)
from .serializers import (
    ReportSerializer,
    ReportCreateUpdateSerializer,
    EmailSendRecordSerializer,
    EmailSendRecordCreateUpdateSerializer,  # 如果需要创建/更新
    TemplateSerializer,
    TemplateCreateUpdateSerializer,
    ScheduledTaskSerializer,
    ScheduledTaskCreateUpdateSerializer,
    TaskLogSerializer,
    IntermediateDataSerializer,
)
from dvadmin.utils.viewset import CustomModelViewSet


class ReportViewSet(CustomModelViewSet):
    """
    简报管理视图集
    """
    queryset = Report.objects.all()
    serializer_class = ReportSerializer
    create_serializer_class = ReportCreateUpdateSerializer
    update_serializer_class = ReportCreateUpdateSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend,]
    filterset_fields = ['type', 'report_date']

    def perform_create(self, serializer):
        serializer.save(creator=self.request.user)

    @action(detail=True, methods=['post'], url_path='send', url_name='send_report')
    def send_report(self, request, pk=None):
        """
        发送简报邮件
        """
        report = self.get_object()
        recipients = request.data.get('recipients', [])

        if not recipients:
            return Response({"detail": "接收者列表不能为空。"}, status=status.HTTP_400_BAD_REQUEST)

        try:
            send_mail(
                subject=report.title,
                message=report.summary,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=recipients,
                html_message=report.content,
                fail_silently=False,
            )
            status_sent = "成功"
        except Exception as e:
            status_sent = "失败"

        email_record = EmailSendRecord.objects.create(
            report=report,
            recipients=';'.join(recipients),
            status=status_sent
        )
        serializer = EmailSendRecordSerializer(email_record)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    @action(detail=True, methods=['get'], url_path='email-history', url_name='email_history')
    def email_history(self, request, pk=None):
        """
        获取简报的邮件发送历史
        """
        report = self.get_object()
        email_records = report.email_records.all()
        serializer = EmailSendRecordSerializer(email_records, many=True)
        return Response({
            "report_id": report.id,
            "email_history": serializer.data
        }, status=status.HTTP_200_OK)


class EmailSendRecordViewSet(CustomModelViewSet):
    """
    邮件发送记录管理视图集
    """
    queryset = EmailSendRecord.objects.all()
    serializer_class = EmailSendRecordSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend,]
    filterset_fields = ['status', 'sent_at']
    search_fields = ['report__title', 'recipients']

    # 如果需要允许创建/更新邮件发送记录，可以设置 create_serializer_class 和 update_serializer_class
    # 例如：
    # create_serializer_class = EmailSendRecordCreateUpdateSerializer
    # update_serializer_class = EmailSendRecordCreateUpdateSerializer


class TemplateViewSet(CustomModelViewSet):
    """
    模板管理视图集
    """
    queryset = Template.objects.all()
    serializer_class = TemplateSerializer
    create_serializer_class = TemplateCreateUpdateSerializer
    update_serializer_class = TemplateCreateUpdateSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend,]
    filterset_fields = ['template_type']

    def perform_create(self, serializer):
        serializer.save(creator=self.request.user)


class ScheduledTaskViewSet(CustomModelViewSet):
    """
    定时任务管理视图集
    """
    queryset = ScheduledTask.objects.all()
    serializer_class = ScheduledTaskSerializer
    create_serializer_class = ScheduledTaskCreateUpdateSerializer
    update_serializer_class = ScheduledTaskCreateUpdateSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend,]
    filterset_fields = ['status', 'frequency']

    def perform_create(self, serializer):
        serializer.save(creator=self.request.user)

    @action(detail=True, methods=['patch'], url_path='update-status', url_name='update_status')
    def update_status(self, request, pk=None):
        """
        更新任务状态（暂停/恢复）
        """
        task = self.get_object()
        new_status = request.data.get('status')

        if new_status not in dict(ScheduledTask.STATUS_CHOICES):
            return Response({"detail": "无效的状态值。"}, status=status.HTTP_400_BAD_REQUEST)

        task.status = new_status
        task.save()
        return Response({"status": task.status}, status=status.HTTP_200_OK)


class TaskLogViewSet(CustomModelViewSet):
    """
    任务日志管理视图集
    """
    queryset = TaskLog.objects.all()
    serializer_class = TaskLogSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend,]
    filterset_fields = ['result', 'start_time']
    search_fields = ['task_name', 'job_id']

    @action(detail=True, methods=['post'], url_path='rerun', url_name='rerun_task')
    def rerun_task(self, request, pk=None):
        """
        重新执行特定任务
        """
        task_log = self.get_object()
        # TODO: 实现任务重新执行的逻辑，例如调用 Celery 任务
        # 示例：
        # from .tasks import execute_scheduled_task
        # new_job = execute_scheduled_task.delay(task_log.job_id)
        # task_log.job_id = new_job.id
        # task_log.result = "执行中"
        # task_log.save()

        # 示例响应
        return Response({"detail": "任务重新调度成功。"}, status=status.HTTP_200_OK)


class IntermediateDataViewSet(CustomModelViewSet):
    """
    中间数据管理视图集
    """
    queryset = IntermediateData.objects.all()
    serializer_class = IntermediateDataSerializer
    permission_classes = [IsAuthenticated]
    filter_backends = [DjangoFilterBackend,]
    filterset_fields = ['date']
    search_fields = ['date', 'job__name']

    def perform_create(self, serializer):
        serializer.save()
